# day11



## 随堂笔记

```
1、关键字搜索

2、高亮显示

3、过滤添加查询
	品牌条件
	
	分类条件
	
	规格条件
		假如规格选项：32G 机身内存 运行内存
	
	
	价格条件
	
4、排序功能
	价格排序
	
	新品排序（更新时间）
	
	定时器技术介绍：
		spring task   quartz
	
5、分页功能
	参数参数：pageNo  pageSize (取值60，因为京东的也是60)
```







## 关键字搜索



商品搜索服务接口



```java
/**
 * 商品搜索服务接口
 */
public interface ItemSearchService {

    //返回数据，经过分析有：当前页商品列表数据，分页相关数据：例如：总页数、当前页等
    // 参数： 提交的数据量多并且不确定，也可以使用 map
    public Map<String,Object> search(Map searchMap);
}
```

分析search方法的返回值和参数类型。**（重点）**



商品列表数据有：



分页相关数据有：



参数：



在进行高亮显示时会发现，angular.js 直接将 `<font color='red'>华为</font> G620 精致黑 联通4G手机` 原样下显示在页面，并没有解析内容中的 html 标签，这是 angularJS 为了防止 html 攻击采取的安全机制。 

解决方案详见代码（或讲义）： 这里利用了 angular.js的过滤器 filter，在前端中我们通过`ng-bind-html` 和 `|`来使用过滤器。

```js
//定义过滤器，处理字符串为HTML标签
//使用方式：<em ng-bind-html="带标签的数据 | trustHtml"></em>
app.filter("trustHtml",function($sce){
    return function(data){
        //借助内置的安全相关的 $sce 服务来配置，让其信任给定数据中的 html标签
        return $sce.trustAsHtml(data);
    };
});
```







## 过滤条件查询

根据品牌 分类 价格 规格进行过滤条件查询。



前端构建查询条件对象：

```js
    //查询条件对象
    $scope.searchMap={
        keywords:"",
        category:"",
        brand:"",
        price:"",
        spec:{},//规格  {}  object map
        sort:"ASC", //排序规则
        sortField:"",//排序字段
        pageNo:1,
        pageSize:60
    };

```







后端过滤查询使用 FilterQuery 对象，创建filterQuery后，最终我们要将其添加到现有的高亮查询对象 query 中来进行总的查询。



```java
        //2 品牌条件查询
        String brand = (String) searchMap.get("brand");
        if(brand!=null && !"".equals(brand)){
            //构建品牌查询条件
            Criteria brandCriteria = new Criteria("item_brand").is(brand);
            //构建品牌过滤条件查询对象
            FilterQuery filterQuery = new SimpleFilterQuery(brandCriteria);
            query.addFilterQuery(filterQuery);//将过滤条件查询对象添加给高亮查询对象（总查询对象）
        }
```



价格条件过滤：

价格的值：类似 `0-500   500-1000  1000-*` 所以先要对其进行分割；关键是对价格的临界值做判断。



规格条件过滤：

先要构建域字段的名称：`"item_spec_"+key `



### 移除条件对象



前端移除即可





### 排序

排序总共有： 综合、销量、新品、评价、价格 

这里只实现 “新品” 和 “价格” 排序；而对 “销量” 和 “价格” *进行了单独的业务分析*



> 销量： 利用定时器来更新每个SKU的销量数据（每天凌晨执行一次即可），可以利用 spring task 技术来实现定时器任务（或者使用 quartz）。



新品：根据商品的更新时间来排序。

**注意： ** 由于之前并没有在 solr 的 schema.xml 文件中配置 update_time相关的域字段，所以这里还需要进行添加。

**注意：** 还需要修改 TbItem 类，还需要进行安装，还需要重启tomcat，还需要更新索引库数据（更新与添加相同）





前端传递排序规则（ASC和DESC之间切换）和 排序字段



后端 使用 Sort 类型的对象

```java
if("ASC".equals(sort)){
    //升序
    query.addSort(new Sort(Sort.Direction.ASC,"item_"+sortField));
}else{
    //降序
    query.addSort(new Sort(Sort.Direction.DESC,"item_"+sortField));
}
```





### 分页





前端分页逻辑很麻烦，见代码。



在实际演示时，会发现下一页按钮不见了，其实它被挤到了下一行，它位于上一页按钮的下面。









# day12



## 随堂笔记



```
1、页面静态化技术freemarker简介
	系统优化常用解决方案
		解决高并发访问。
	
		基于搜索的商品，点击该商品后，展示商品详情信息时，数据是完全可以从数据库查询后，在填充到页面上。
		
		为什么不每次都直接从数据库取数据，再展示在页面上呢？
			1、商品数据量巨大，并且从三张表中获取数据。所以查询性能很差
			2、商品详情查看功能是频繁操作，如果每次从数据库中获取数据，给数据库造成很大的访问压力。
			
		解决方案：
			1、将数据缓存到redis  数据量小，并且经常查询，很少发生变化的数据。
			2、页面静态化。
		
		什么时候生成静态页呢？
			商品上架的时候。
			tb_goods完成商品上架
	
	什么是freemarker，为什么使用freemarker
		freemarker是模板技术。
	
	
2、freemarker入门demo
	freemarker模板后缀是 .ftl
	

3、freemarker FTL指令、内建函数、空值处理、运算符

4、商品详情页数据分析以及后端代码组装数据实现

5、模板构建、基本数据展示(标题、价格、商品介绍、包装列表、售后保障等)

6、图片列表展示、规格数据展示、分类数据展示

7、静态页面动态效果实现
	商品数量加减操作
	
	勾选默认商品规格数据
	
	切换勾选商品规格时，切换加载的页面
	
8、一次性生成所有商品静态页面（批量生成静态页）
```



## freemarker Demo



略



## 在项目中应用freemarker



### 项目中何时进行页面静态化操作？



通过分析，我们应该在商品上架的时候同时对该商品的详情页面进行静态化，在商品下架时删除其现存的静态化页面(html文件)。



为了完成这一操作，我们为页面静态化单独创建一个服务，以便在商品上下架时调用该服务。



```
pinyougou_page_interface  
pinyougou_page_service  （用于查询静态化商品数据，即商品详情页数据）
pinyougou_page_web (生成静态的商品详情页，成功后返回success)
```





pinyougou_page_web：配置

springmvc.xml 文件中还需要配置 FreeMarkerConfigurer 的**模板加载路径**（仅仅是模板加载路径）

```xml
	<!-- 相当于 freemarkerDemo 中编写的java文件中的 Configuration对象的配置 -->
	<bean id="freemarkerConfig"
		  class="org.springframework.web.servlet.view.freemarker.FreeMarkerConfigurer">
		<property name="templateLoaderPath" value="/WEB-INF/ftl/" />
		<property name="defaultEncoding" value="UTF-8" />
	</bean>
```



## 商品详情页分析



在商品上架时操作的是 tb_goods表（根据表中的 is_marketable），我们需要在此时生成静态页面。



商品详情页涉及三张表：而我们已经创建了一个Goods组合类来包含了相同的pojo

- tb_goods
- tb_goods_desc
- tb_item

根据 goods_id 查询三张表。





静态资源的生成路径：

```
Writer out = new FileWriter("I:\\pinyougou\\item"+tbItem.getId()+".html");
```

但是注意还需要手动将其所需的js、css等文件放入`I:\pinyougou\item` 文件夹，这样在访问 html 页面时才会正常显示。





为了方便组装商品分类数据，我们在Goods类中添加一个itemCatMap字段。







## 模板页面

> 技巧，提前在后端将 item数据取出。



由于商品详情页面太长，我们将对其进行拆分，然后通过Freemarker的 include进行包含





商品介绍在 left.ftl 中



访问路径：

```
localhost:8085/genItemHtml.do?goodsId=149187842867960
```





## 商品规格勾选

SPU：标准生产单位

SKU：最小库存量单位  最小销售单元  



每个页面对应一个 SKU，也就是说每个页面对应一组选中的规格（默认选中的规格），当切换规格时需要加载不同的页面。



### 默认规格的勾选

通过对比 每个页面独有的 `tbItem.spec`，与页面生成的规格列表中的数据进行对比，如果匹配则将其标记为已经勾选。

所以我们先在页面生成这个  `tbItem.spec`

```
//spec={"网络":"移动3G","机身内存":"64G"}
var spec=${tbItem.spec!""}
```



对比的数据来源：goods中取出

```html
<#assign specList=goods.goodsDesc.specificationItems?eval>
```

其数据形式为：

```
[{"attributeValue":["移动3G","移动4G"],"attributeName":"网络"},
{"attributeValue":["64G","128G"],"attributeName":"机身内存"}]
```



利用三元运算进行判断，为该标签的 class 属性添加值

```html
class="{{isSelected('${spec.attributeName}','${value}')?'selected':''}}"
```



isSelected函数：

```js
    //判断规格选项是否需要选中的方法
    $scope.isSelected = function(specName, specValue){
        if(spec[specName]==specValue){
            return true;
        } else{
            return false;
        }
    }
```





### 规格的切换



要完成切换先要获取到选中的规格对应的 item的id，我们可以先在页面构造如下形式的数据：

数据的要点是： 规格列表中的每一个对象都包含对应的 item_id， 这样我们可以通过找到对应的 spec 来找到对应的 item_id值，然后就可以通过在js中进行页面跳转。

```js
		//规格列表数据
		/*var specList=[
			{"id":1369288,"spec":{"网络":"移动3G","机身内存":"64G"}},
			{"id":1369289,"spec":{"网络":"移动3G","机身内存":"128G"}},
			{"id":1369290,"spec":{"网络":"移动4G","机身内存":"64G"}},
			{"id":1369291,"spec":{"网络":"移动4G","机身内存":"128G"}},
		];
		*/
        var specList=[
		    <#list goods.itemList as item>
			{"id":${item.id?c},"spec":${item.spec}},
			</#list>
        ];
```





具体步骤见js文件





# day13



解耦





## 项目对接







### 配置hosts



建议使用  [SwitchHosts!](https://oldj.github.io/SwitchHosts/ "SwitchHosts!")，软件进行hosts切换，需要以管理员身份运行，这里可以修改其快捷方式属性，为其勾选"以管理员身份运行"

```
127.0.0.1 www.pinyougou.com
127.0.0.1 manager.pinyougou.com
127.0.0.1 shop.pinyougou.com
127.0.0.1 search.pinyougou.com
127.0.0.1 item.pinyougou.com
127.0.0.1 user.pinyougou.com
127.0.0.1 passport.pinyougou.com
127.0.0.1 seckill.pinyougou.com
127.0.0.1 cart.pinyougou.com
127.0.0.1 pay.pinyougou.com
```







### 使用Nginx做反向代理



这里我使用 scoop 安装了 nginx。



**配置 nginx.conf**



```

#user  nobody;
worker_processes  1;

#error_log  logs/error.log;
#error_log  logs/error.log  notice;
#error_log  logs/error.log  info;

#pid        logs/nginx.pid;


events {
    worker_connections  1024;
}


http {
    include       mime.types;
    default_type  application/octet-stream;

    #log_format  main  '$remote_addr - $remote_user [$time_local] "$request" '
    #                  '$status $body_bytes_sent "$http_referer" '
    #                  '"$http_user_agent" "$http_x_forwarded_for"';

    #access_log  logs/access.log  main;

    sendfile        on;
    #tcp_nopush     on;

    #keepalive_timeout  0;
    keepalive_timeout  65;

    #gzip  on;

    #######################  以下内容为品优购项目配置  ####################
    
    server {
        listen       80;
        server_name  manage.pinyougou.com;
        location / {
            proxy_pass http://127.0.0.1:8081;
            root   admin/;
            index  admin/index.html;
        }
    }
   server {
        listen       80;
        server_name  shop.pinyougou.com;
        location / {
            proxy_pass http://127.0.0.1:8082;
            root   admin/;
            index  admin/index.html;		
        }
    }

    server {
        listen       80;
        server_name  www.pinyougou.com;
        location / {
            proxy_pass http://127.0.0.1:8083;
            root   /;
            index  index.html;
        }
    }
	
	server {
        listen       80;
        server_name  search.pinyougou.com;
        location / {
            proxy_pass http://127.0.0.1:8084;
            root   /;
            index  search.html;
        }
    }
	
	server {
        listen       80;
        server_name  cart.pinyougou.com;
        location / {
            proxy_pass http://127.0.0.1:9107;
            root   /;
            index  cart.html;
        }
    }
	
	server {
        listen       80;
        server_name  item.pinyougou.com;
        location / {
            root   I:\\pinyougou\\items;
            index  index.html;
        }
    }
	

    ###########################################
}
```





如果出现下面的错误：

则需要再nginx的安装目录运行。

```
$ nginx.exe
nginx: [alert] could not open error log file: CreateFile() "logs/error.log" failed (3: The system cannot find the path specified)
2018/10/11 09:03:25 [emerg] 10644#10084: CreateFile() "D:\Fan Dean/conf/nginx.conf" failed (3: The system cannot find the path specified)
```





### 修改相应代码







## JMS与消息中间件

JMS即 Java消息服务（Java Message Service）应用程序接口，是一个Java平台中关于面向消息中间件（MOM）的API，用于在两个应用程序之间，或分布式系统中发送消息，进行异步通信。Java消息服务是一个与具体平台无关的API，绝大多数MOM提供商都对JMS提供支持。



- JMS是API （规范）
- 消息中间件是具体产品





常见消息中间件：

- ActiveMQ (这里我们使用它)
- RabbitMQ
- ZeroMQ
- Kafka





JMS 定义了五种不同的**消息正文格式**，以及调用的消息类型，允许你发送并接收以一些不同形式的数据，提供现有消息格式的一些级别的兼容性。

- TextMessage--一个字符串对象
- MapMessage--一套名称-值对
- ObjectMessage--一个序列化的 Java 对象
- BytesMessage--一个字节的数据流
- StreamMessage -- Java 原始值的数据流 



JMS消息传递类型：

- 点对点
- 发布/订阅模式







## ActiveMQ



> ActiveMQ此服务作用类似于存储消息



端口：

http（访问管理界面）：端口8161   `http://192.168.25.146:8161`

tcp（ 连接协议tcp  基于java程序连接activeMQ消息中间件的端口号）：端口  61616   `tcp://192.168.25.146:61616`







    //5.创建队列对象 （消费者创建的queue名字必须与生产者创建的queue的名字一致）
    Queue queue = session.createQueue("queue_test");




# day14



## Apache HttpClient









## 阿里短信服务（阿里大于）









