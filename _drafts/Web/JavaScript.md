## JavaScript

《JavaScript编程全解》介绍了一些实用方法。  

《JavaScript高级程序设计》  







传统意义上，JavaScript 是由下列三部分组成：

- **ECMAScript** 
- **文档对象模型(DOM)**  是针对 XML 但经过扩展用于 HTML 的应用程序编
  程接口(API,Application Programming Interface)
   。DOM 把整个页面映射为一个多层节点结构。
- **浏览器对象模型(BOM)** 支持可以访问和操作浏览器窗
  口

而 Mozilla 则指出 JavaScript 由**Core** JavaScript 和 **Client** JavaScript 组成。



## 基础学习

[JavaScript 简介 - 菜鸟教程](http://www.runoob.com/js/js-intro.html "JavaScript 简介 - 菜鸟教程")

DOM (**D**ocument **O**bject **M**odel)（文档对象模型）是用于访问 HTML 元素的正式 W3C 标准。



JavaScript 可以通过不同的方式来输出数据：

- 使用 **window.alert()** 弹出警告框。
- 使用 **document.write()** 方法将内容写到 HTML 文档中。
- 使用 **innerHTML** 写入到 HTML 元素。
- 使用 **console.log()** 写入到浏览器的控制台。



> 请使用 document.write() 仅仅向文档输出写内容。
>
> 如果在文档已完成加载后执行 document.write，整个 HTML 页面将被覆盖。
>
> document.write是直接写入到页面的**内容流**，如果在写之前没有调用document.open, 浏览器会自动调用open。每次写完关闭之后重新调用该函数，会导致页面被重写。



### 字面量

| 数值         | 100                         |
| ---------- | --------------------------- |
| 字符串值       | "foobar"                    |
| 布尔值        | true                        |
| null值      | null                        |
| **Object** | {x:1,y:2}                   |
| 数列         | [3,1,2]  //这里使用的是方括号，而不是大括号 |
| **函数**     | function(){return ;}        |
| 正则表达式      | /foo/                       |
|            |                             |

相等运算符： `===`



### 变量

ECMAScript 的变量是松散类型的，每个变量仅仅是一个用于保存值的占位符而已。定义变量时要使用 var 操作符。

```javascript
var message;
```

该变量可以用来保存任何值 (像这样未经过初始化的变量,会保存一个特殊的值—— **undefined**)。

注意：即用 var 操作符定义的变量将成为定义该变量的作用域中的局部变量。

> 省略 var 操作符可以定义**全局变量**,但这不是我们推荐的做法。



### 数据类型

ECMAScript 中有 5 种简单数据类型(也称为**基本数据类型**) : 

- **Undefined**
- **Null**
- **Boolean** ：只有两个字面值: true 和 false。(Number：0和NaN转换为false，其它转换为true)
- **Number**：它的一个**特殊值NaN**表示非数值(Not a Number)是一个特殊的数值，它用于表示一个本来要返回数值的操作数未返回数值的情况。它有**两个特点**：1. 任何涉及NaN的操作都会返回NaN。2. NaN与任何值都不相等(包括NaN本身)。所以为其提供了`isNaN()`函数。
- **String**

还有 1 种**复杂数据类型**——Object, Object 本质上是由**一组无序的名值对组成**的。 



**typeos操作符：**

可以通过 typeof 操作符检测一个变量的数据类型。(可以用括号也可不用)

**注意：** typeof 返回 "function"——则表示这个值是**函数**。



从技术角度上讲，**函数在ECMAScript中是对象**，不是一种数据类型。然而函数确实有一些特殊的属性，因此通过typeof操作符来区分函数和其它对象是有必要的。



#### String

ECMAScript 中的字符串是不可变的,也就是说,字符串一旦创建,它们的值就不能改变。要改变
某个变量保存的字符串,首先要销毁原来的字符串,然后再用另一个包含新值的字符串填充该变量



### 操作符和语句



#### 浮点型数据使用注意事项

所有的编程语言，包括 JavaScript，对浮点型数据的精确度都很难确定：

```javascript
var x = 0.1;
var y = 0.2;
var z = x + y            // z 的结果为 0.3
if (z == 0.3)            // 返回 false
```

为解决以上问题，可以用整数的乘除法来解决：

```javascript
var z = (x * 10 + y * 10) / 10;       // z 的结果为 0.3
```





#### 相等操作符

ECMAScript提供了两组操作符：

- 相等`==`和不等`!=`：在比较之前先将对象转换成相似的类型。
- 全等`===`和不全等`!==`：在比较之前不做任何转换操作。




#### switch语句

switch 语句会使用全等运算符(===)进行比较，而非相等运算符。





#### for in语句

for in语句是用于枚举**对象属性**名的循环语句。

in 的右侧是 Object 类型的表达式；而任何类型的值都可以转换为Object类型。

```javascript
var obj = {x:1, y:3, z:2};
for (var k in obj){ //这里并不保证枚举的顺序
    print(k);
}
```




### 函数

函数声明：

```javascript
//函数声明语句
function 函数名 (参数, 参数, ...){
    函数体
}
```



省略函数名的函数为**匿名函数**。

**匿名函数表达式**是一种表达式而非语句，所以也可以在表达式内使用。另外由于它是表达式因此也会有返回值。匿名函数的返回值是一个 Function 对象的引用。

```javascript
var sum = function(a,b){
    return Number(a) + Number(b);
}

//调用函数 sum
sum(3,4);
```



JavaScript中的**函数也是一种特殊对象**。变量名与函数名实质上是相同的。

可以把任意类型的值、对象或者函数赋值给对象的属性。

```javascript
obj.fn = function(a,b){
    return Number(a) + Number(b);
};
```







不必声明返回值：

```javascript
//没有指定是否有返回值
function sum(num1, num2) {
  	//也可以 return
	return num1 + num2;
}

function sayHi(name, message) {
  	//返回 undefined 值
	return;
}
```





#### 理解参数

ECMAScript 函数不介意传递进来多少个参数,也不在乎传进来参数是什么数据类型。也就是说,即便你定义的函数只接收两个参数,在调用这个函数时也未必一定要传递两个参数。可以传递一个、三个甚至不传递参数。

之所以会这样,原因是 ECMAScript 中的参数在内部是用一个数组来表示的。函数接收
到的始终都是这个数组,而不关心数组中包含哪些参数(如果有参数的话)。如果这个数组中不包含任
何元素,无所谓;如果包含多个元素,也没有问题。

实际上,在函数体内可以通过 arguments 对象来访问这个参数数组,从而获取传递给函数的每一个参数。

通过访问 arguments 对象的 length 属性可以获知有多少个参数传递给了函数。

另一个与参数相关的重要方面,就是 arguments 对象可以与命名参数一起使用；并且它的值永远与对应命名参数的值保持同步（注意它们的内存空间可是独立的）。

```javascript
// arguments与命名参数一起使用
function doAdd(num1, num2) {
	if(arguments.length == 1) {
		alert(num1 + 10);
	} else if (arguments.length == 2) {
		alert(arguments[0] + num2);
	}
}
```



另外；没有传递值的命名参数将自动被赋予 undefined 值。





#### 不能重载

ECMAScript 函数不能像传统意义上那样实现重载。如前所述,ECMAScirpt函数没有签名,因为其参数是由包含零或多个值的数组来表示的。而没有函数签名,真正的重载是不可
能做到的。

如果在 ECMAScript 中定义了两个名字相同的函数,则该名字**只属于后定义的函数**。



### 变量、作用域和内存问题

ECMAScript 变量可能包含两种不同数据类型的值: **基本类型值** 和 **引用类型值**。

> 注意：ECMAScript 中 String 也是基本类型之一。



#### 动态的属性

对于引用类型的值,我们可以为其添加属性和方法,也可以 **改变** 和 **删除** 其 **属性 和 方法**。

```javascript
var person = new Object();
person.name = "Nicholas";  //动态添加的属性
alert(person.name);   //"Nicholas"
```



#### 复制变量值

- 基本类型：复制原内存
- 引用类型：复制指针值



#### 传递参数

所有函数的参数都是按值传递的

- 基本类型：复制内存中的值
- 引用类型：复制指针值



#### 检测类型

- 基本类型：使用 typeof 操作符检测。`typeof i` 或`typeof(i)`
- 引用类型：使用 instanceof 操作符检测。`result = variable instanceof constructor`



> ECMA-262 规定任何在内部实现 `[[Call]]`方法的对象都应该在应用typeof操作符时返回 "function"。函数实现了这个方法。在Chrome 7和某些浏览器中的正则表达式也实现了这个方法，所以检测正则表达式时也会返回"function"。



in 操作符：可以用来检测某属性是否存在。



#### 执行环境及作用域

执行环境(execution context,为简单起见,有时也称为“环境”)是 JavaScript 中最为重要的一个概
念。执行环境定义了变量或函数有权访问的其他数据,决定了它们各自的行为。每个执行环境都有一个
与之关联的变量对象(variable object),环境中定义的所有变量和函数都保存在这个对象中。虽然我们
编写的代码无法访问这个对象,但解析器在处理数据时会在后台使用它。

全局执行环境是最外围的一个执行环境。在 Web 浏览器中,全局执行环境被认为是 **window** 对象。因
此所有全局变量和函数都是**作为 window 对象的属性和方法创建的**。

> 全局变量（以及全局函数名）是全局对象的属性。

某个执行环境中的所有代码执行完毕后,该环境被销毁,保存在其中的所有变量和函数定义也随之销毁。

每个函数都有自己的执行环境。

当代码在一个环境中执行时,会创建变量对象的一个**作用域链(scope chain)**。作用域链的用途,是保证对执行环境**有权访问**的所有变量和函数的**有序访问**。 （嵌套的作用域）

作用域链的 **前端**,始终都是当前执行的代码所在环境的变量对象。

标识符解析是沿着作用域链一级一级地搜索标识符的过程。

内部环境可以通过作用域链访问所有的外部环境,但外部环境不能访问内部环境中的任何变量和函数。这些环境之间的联系是线性、有次序的。每个环境都可以向上搜索作用域链,以查询变量和函数名;但任何环境都不能通过向下搜索作用域链而进入另一个执行环境。



#### 延长作用域链

虽然执行环境的类型总共只有两种 — 全局和局部(函数),但还是有其他办法来延长作用域链。

在下面的两种情况会在作用域的**前端** 临时 **增加一个变量对象**；该变量对象会在代码执行后被移除。

- try-catch 语句的 **catch 块** ： 对 catch 语句来说,会创建一个新的变量对象,其中包含的是被抛出的错误对象的声明。
- with语句：对 with 语句来说,会将指定的对象**添加到作用域链中**。



#### 没有块级作用域

在C语言中，由花括号封闭的代码块都有自己的作用域。而 **JavaScript 没有块级作用域**。

所以在使用 if 语句 和 for 语句时要记住这一点。



### 垃圾收集

JavaScript 具有自动垃圾收集机制,也就是说,执行环境会负责管理代码执行过程中使用的内存。



而优化内存占用的最佳方式,就是为执行中的代码只保存必要的数据。一旦数据不再有用,最好通过将其值设置为 null 来释放其引用——这个做法叫做**解除引用**(dereferencing)。



## 引用类型

引用类型的**值(对象)**是引用类型的一个实例。在 ECMAScript 中，引用类型是一种数据结构，用于将数据和功能组织在一起。它也常被称为类,但这种称呼并不妥当。 ECMAScript 它**不具备**传统的面向对象语言所支持的**类**和**接口**等基本结构。



> 虽然**引用类型**与**类**看起来相似 , 但它们并不是相同的概念。



#### Object类型

我们看到的大多数引用类型值都是 Object 类型的实例。

创建Object实例的两种方式。

1. 使用new操作符后跟Object构造函数：

   ```javascript
   var person = new Object();
   person.name = "Nicholas";
   person.age = 29;
   ```

2. 使用**对象字面量**表示法。它是对象定义的一种简写形式，目的在于简化创建包含大量属性的对象的过程。

   ```javascript
   var person = {
       name : "Nicholas",
     	age : 29
   };
   ```

   ​

#### 访问对象属性

访问对象属性的两种方法：

- 使用点表示法。`person.name`
- 使用方括号表示法。`person["name"]`

方括号表示法的优点：可以通过变量来访问属性。

```javascript
var propertyName = "name";
//向方括号中传入一个变量
var userName = person[propertyName];
```

通常,除非必须使用变量来访问属性,否则我们建议使用**点表示法**。



#### Array类型

ECMAScript 中的数组与其他多数语言中的数组有着相当大的区别。

- ECMAScript 数组的每一项可以保存任何类型的数据。
- ECMAScript 数组的大小是可以动态调整的




Array 的特性较多，这里不再说明。

判断某个变量是否是数组： Array.isArray() 方法。



**栈方法：**

- 数组的push()方法
- 数组的pop()方法



**队列方法：**

- 数组的shift()方法
- 数组的push()方法



**重排序方法：**

- 反转数组项的顺序：reverse() 
- 排序方法(默认升序)： sort()。也可以传入一个**比较函数**作为参数。



**操作方法：**

- concat() 方法进行连接
- slice() 切片方法
- splice() 拼接方法。可以进行删除、插入、替换。



**位置方法：**

- indexOf() : 
- lastIndexOf() : 



**迭代方法：**

迭代方法很高级，需要掌握。它们都接收一个**函数**作为参数。



ECMAScript 5 为数组定义了 5 个迭代方法：

-  map(): 对数组中的每一项运行给定函数，**返回**每次函数调用的结果组成的**数组**。进行**映射**。
-  every()：数组中的所有项是否满足条件。
-  filter()：过滤数组。
-  forEach()：对数组中的每个值都执行一次操作。
-  some()：检测数组中是否存在满足条件的值。





#### Date类型





#### RegExp类型

使用下面的方法就可以创建一个正则表达式：

```javascript
var expression = /pattern/flags;
```



flags: 

- g：表示全局模式
- i：表示不区分大小写模式
- m：表示多行模式



另一种创建正则表达式的方式是使用RegExp 构造函数,它接收两个参数:一个是要匹配的字符串模式,另一个是可选的标志字符串。



#### Function类型

函数实际上是对象。每个函数都是 Function 类型的实例，**而且都与其他引用类型一样具有属性和方法**。

因此函数名实际上也是一个指向函数对象的指针，**不会与某个函数绑定**。

```javascript
var sum = function(num1,num2){
    return num1 + num2;
}; //这里有分号
```



**作为值的函数：**

因为ECMAScript中的函数名本身就是一个变量，所以函数也可作为值来使用。也就是说，不仅可以像传递参数一样把一个函数传递给另一个函数，而且可以将一个函数作为另一个函数的结果返回。

**函数内部属性：**

在函数内部，有两个特殊的对象：**arguments** 和 **this**。





## 面向对象的程序设计

ECMAScript中**没有类**的概念。从形式上来看 JavaScript 的对象就是一种属性的集合。

我们可以把ECMAScript的对象想象成散列表：无非就是一组名值对，其中值可以是**数据**或**函数**。

如果将JavaScript对象的属性名看作键，属性值看作值；会发现它与Java中的映射(Map)非常相似（附加功能是方法和原型继承等）。

从本质上来说，**面向对象**这一术语只不过是一种在高于内部实现的语境中所使用的、较为抽象的概念而已。

在JavaScript中，一切都是对象。对象之间的协作通过属性访问来实现。而对象之间的共性，则通过继承同一个对象的性质的方式来实现；**而JavaScript通过基于原型的形式来实现继承**。



**自定义一个对象**

早期做法：*创建一个Object实例*，再为其添加属性和方法

```javascript
var person = new Object();
person.name = "Nicholas";
person.age = 29;
person.job = "Software Engineer";
person.sayName = function(){
alert(this.name);
};
```

流行做法：对象字面量

```javascript
var person = {
  name: "Nicholas",
  age: 29,
  job: "Software Engineer",
  sayName: function(){
    alert(this.name);
  }
};
```



> 作为 singleton模式的用法：
>
> 对类（构造函数）进行设计以实现singleton模式的想法完全是一种基于类的思考方式。
>
> 在JavaScript中我们只需要**直接使用对象字面量**即可。





**属性**在创建时都带有一些**特征值**(characteristic) ,JavaScript 通过这些特征值来定义它们的行为。

特征值比较高级，这里略过。







## 函数表达式














## 进阶学习

《JavaScript高级程序设计》





